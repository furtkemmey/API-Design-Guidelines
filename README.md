# API-Design-Guidelines
API Design Guidelines
API Design Guidelines
To facilitate use as a quick reference, the details of many guidelines can be expanded individually. Details are never hidden when this page is printed. 
https://swift.org/documentation/api-design-guidelines/

Table of Contents
* Fundamentals
* Naming
    * Promote Clear Usage
    * Strive for Fluent Usage
    * Use Terminology Well
* Conventions
    * General Conventions
    * Parameters
    * Argument Labels
* Special Instructions
Fundamentals(基礎)
* Clarity at the point of use is your most important goal. Entities such as methods and properties are declared only once but used repeatedly. Design APIs to make those uses clear and concise. When evaluating a design, reading a declaration is seldom sufficient; always examine a use case to make sure it looks clear in context.(在使用上清晰明確是最重要的點.函數跟屬性只被宣告一次但是會一直重複被使用.簡潔地清晰地設計API.當評估一個設計,很少地閱讀宣告;總是檢查內容是明確的的.) 
* Clarity is more important than brevity. Although Swift code can be compact, it is a non-goal to enable the smallest possible code with the fewest characters. Brevity in Swift code, where it occurs, is a side-effect of the strong type system and features that naturally reduce boilerplate.(清晰比簡短還重要.雖然swift語言是緊湊的,他不是以最小最少字數為目標.Swift代碼的簡潔性是因為它的強類型系統以及自然地減少樣板的副作用) 
* Write a documentation comment for every declaration. Insights gained by writing documentation can have a profound impact on your design, so don’t put it off.(為每一個宣告寫文件註解.透過寫文件撰寫可以對你的API設計有深遠的影響,所以不要關閉它) If you are having trouble describing your API’s functionality in simple terms, you may have designed the wrong API.(如果你不能簡單的描述你的API,你也許設計了錯誤的API) 
    * Use Swift’s dialect of Markdown.(使用Markdown語言,參考連結) 
    * Begin with a summary that describes the entity being declared. Often, an API can be completely understood from its declaration and its summary.(這個實體被宣告開始地方描述概要,通常從宣告跟描述概要可以完全了解一個API,範例如下) /// Returns a "view" of `self` containing the same elements in
    * /// reverse order.
    * func reversed() -> ReverseCollection
    *  
        * Focus on the summary; it’s the most important part. Many excellent documentation comments consist of nothing more than a great summary.(重點總結,這是最重要的.大多數優秀的文件註解都是比較’精’,少的) 
        * Use a single sentence fragment if possible, ending with a period. Do not use a complete sentence.(使用簡短的片段,不要使用完整的句子) 
        * Describe what a function or method does and what it returns, omitting null effects and Void returns:(敘述函數功能和回傳,忽略沒作用的null和void回傳) /// Inserts `newHead` at the beginning of `self`.
        * mutating func prepend(_ newHead: Int)
        * 
        * /// Returns a `List` containing `head` followed by the elements
        * /// of `self`.
        * func prepending(_ head: Element) -> List
        * 
        * /// Removes and returns the first element of `self` if non-empty;
        * /// returns `nil` otherwise.
        * mutating func popFirst() -> Element?
        *   Note: in rare cases like popFirst above, the summary is formed of multiple sentence fragments separated by semicolons. 
        * Describe what a subscript accesses: /// Accesses the `index`th element.
        * subscript(index: Int) -> Element { get set }
        *   
        * Describe what an initializer creates: /// Creates an instance containing `n` repetitions of `x`.
        * init(count n: Int, repeatedElement x: Element)
        *   
        * For all other declarations, describe what the declared entity is. /// A collection that supports equally efficient insertion/removal
        * /// at any position.
        * struct List {
        * 
        *   /// The element at the beginning of `self`, or `nil` if self is
        *   /// empty.
        *   var first: Element?
        *   ...
        *   
    *  
    * Optionally, continue with one or more paragraphs and bullet items. Paragraphs are separated by blank lines and use complete sentences. /// Writes the textual representation of each    ← Summary
    * /// element of `items` to the standard output.
    * ///                                              ← Blank line
    * /// The textual representation for each item `x` ← Additional discussion
    * /// is generated by the expression `String(x)`.
    * ///
    * /// - Parameter separator: text to be printed    ⎫
    * ///   between items.                             ⎟
    * /// - Parameter terminator: text to be printed   ⎬ Parameters section
    * ///   at the end.                                ⎟
    * ///                                              ⎭
    * /// - Note: To print without a trailing          ⎫
    * ///   newline, pass `terminator: ""`             ⎟
    * ///                                              ⎬ Symbol commands
    * /// - SeeAlso: `CustomDebugStringConvertible`,   ⎟
    * ///   `CustomStringConvertible`, `debugPrint`.   ⎭
    * public func print(
    *   _ items: Any..., separator: String = " ", terminator: String = "\n")
    *  
        * Use recognized symbol documentation markup elements to add information beyond the summary, whenever appropriate. 
        * Know and use recognized bullet items with symbol command syntax. Popular development tools such as Xcode give special treatment to bullet items that start with the following keywords:
▪	Attention	▪	Author	▪	Authors	▪	Bug
▪	Complexity	▪	Copyright	▪	Date	▪	Experiment
▪	Important	▪	Invariant	▪	Note	▪	Parameter
▪	Parameters	▪	Postcondition	▪	Precondition	▪	Remark
▪	Requires	▪	Returns	▪	SeeAlso	▪	Since
▪	Throws	▪	Todo	▪	Version	▪	Warning
    * 	◦	 
*  
Naming
Promote Clear Usage
* Include all the words needed to avoid ambiguity for a person reading code where the name is used.(為了人們閱讀程式碼時必須包含所有的字避免模糊不清範例如下) For example, consider a method that removes the element at a given position within a collection.(插入一個元素at位置) extension List {
*   public mutating func remove(at position: Index) -> Element
* }
* employees.remove(at: x)
*   If we were to omit the word at from the method signature, it could imply to the reader that the method searches for and removes an element equal to x, rather than using x to indicate the position of the element to remove.(如果沒有at會誤認移除x) employees.remove(x) // unclear: are we removing x?
*    

